# 0.1 Назначение, Моделирование и Симуляция

## 0.1.0 Введение

Стандарт определяет процесс разработки программного обеспечения в трех основных категориях: Назначение, Моделирование и Симуляция. Каждый аспект важен для того, чтобы направить инженерные усилия к успешному решению и выполнению задачи.

Последовательность следования этих аспектов также не случайна. Назначение должно существовать для того, чтобы формировать процесс моделирования, а симуляцию нельзя проводить без моделей. Однако, хотя этот порядок важен на начальном этапе инженерного процесса, важно понимать, что процесс выборочно итеративен. Изменение назначения может повлиять на симуляцию, но не обязательно на моделирование, а изменение моделей не всегда требует изменения назначения или симуляции.

<br />
	<div align=center>
		<img width="45%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard-Russian/refs/heads/main/0.%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5/%D0%A0%D0%B5%D1%81%D1%83%D1%80%D1%81%D1%8B/%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%2C%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F/Purposing%20Modeling%20%26%20Simulation-1.drawio.png" />
	</div>
<br />

## 0.1.1 Назначение

Процесс назначения — это наша способность выяснить, зачем нам нужно решение. Например, если у нас есть проблема с подсчетом количества товаров на полке в продуктовом магазине, мы считаем, что процесс ручного подсчета неэффективен, и требуется система, чтобы обеспечить правильный учет товаров.

Размышление во многом опирается на нашу способность наблюдать за проблемами, а затем формулировать проблему для разработки решения, которое устранит данную проблему. Назначение, таким образом, — это поиск причины для действий.

Итак, у нас есть наблюдение, формулировка причины (проблемы) и намерение найти решение. Все эти аспекты составляют часть Назначения в разработке программного обеспечения.

### 0.1.1.0 Наблюдение

Мы живем в мире, полном объектов наблюдения. Наше вдохновение вызывается нашей амбицией достигать большего. Наши мечты выявляют преграды на нашем пути, которые нужно решить, чтобы продолжить наше путешествие и воплотить мечты в жизнь. С момента, когда молодой студент использует калькулятор для решения сложного уравнения, до момента, когда этот же студент становится астронавтом, рассчитывающим траекторию спутников, вращающихся вокруг нашей планеты.

Наблюдение — это наша способность обнаружить проблему, которая блокирует достижение цели. Проблемы могут быть простыми, как правильный подсчет товаров на полке магазина, или сложными, как понимание того, почему мы не можем сделать снимки планет, находящихся на миллионы световых лет от нас. Инженеры называют это наблюдаемыми проблемами.

Чем больше цель, тем сложнее будет проблема. Но начинать с меньших целей — это способ тренировать наш ум для решения более крупных — шаг за шагом, по одной проблеме за раз.

### 0.1.1.1 Формулировка

Описание наблюдаемого — это искусство само по себе, потому что хорошо сформулированная проблема — это уже половина решения. Чем яснее формулировка проблемы, тем больше вероятность, что другие поймут её, что поможет в решении этой же проблемы.

Формулировка не всегда выражается словами. Это также могут быть фигуры и формы. Недаром некоторые из самых развитых древних культур использовали фигуры и формы для описания своего времени и истории. Фигуры — это универсальный язык, который быстрее воспринимается и интерпретируется кем-либо, чем изучение разговорного языка. Фигура или форма может быть самым оптимальным способом иллюстрации идеи, так как изображения ценнее тысячи слов.

Формулировка требует страсти к решению проблемы, будь она написана, произнесена или иллюстрирована. Страстный ум передает скрытое сообщение о критичности проблемы, которую нужно решить. Формулирование проблемы — важная часть презентации решения. Наша способность донести идею до других инженеров и тех, кто инвестирует и использует это решение, является одним из самых важных аспектов разработки программного обеспечения.

### 0.1.1.2 Решение

Часть назначения — это способ его выполнения. В индустрии разработки достижение целей не может происходить "любыми средствами". Программное обеспечение терпит неудачи по всему миру, потому что аспект решения был упущен как тривиальная часть назначения. Возможно, вы слышали о инженерах, которые, столкнувшись с крайним сроком, решают пойти на компромиссы для достижения цели. В нашем Стандарте это является нарушением. Решение *должно* не просто достигать цели, но и само быть частью назначения, чтобы способствовать решению таких вопросов, как оптимизация, читаемость, конфигурируемость и долговечность. Решение является частью назначения в искусстве разработки программного обеспечения.

## 0.1.2 Моделирование

Моделирование — второй по важности аспект разработки программного обеспечения. Мы можем извлекать модели из участников любой проблемы, будь то живые существа, объекты или другие элементы. Мы извлекаем только те атрибуты, которые важны для решения проблемы, и отбрасываем всё остальное. Например, при подсчете товаров на полке в продуктовом магазине нам понадобится модель для этих товаров.

Более простой пример — обнаружение скоропортящихся товаров в магазине. Единственный атрибут, который нас здесь интересует, — это срок годности товара. Всё остальное, включая этикетку, цвет, вес или любые другие детали, не имеет отношения к процессу моделирования и решению.

Моделирование, таким образом, может существовать только при наличии цели. Цель определяет рамки, в пределах которых должно происходить моделирование. Моделирование без цели оставляет открытой дверь для привлечения бесконечного количества атрибутов, которые может иметь каждый элемент наблюдаемой вселенной.

Отношение между назначением и атрибутами моделирования пропорционально. Чем сложнее цель, тем более вероятно, что процесс моделирования потребует больше атрибутов из реального мира для моделирования в решении.

Мы выражаем наши модели на языках программирования в виде `class` - класса. Проблема скоропортящихся товаров, упомянутая выше, может быть представлена следующим образом:

```csharp
public class Элемент
{
	public DateTimeOffset ДатаИстеченияСрока {get; set;}
}
```

Название `class` - класс представляет собой общий *тип* элемента. Поскольку все элементы имеют одинаковый атрибут `ДатаИстеченияСрока`, имя должно оставаться максимально общим.

Теперь представьте, что наша цель стала более сложной. Допустим, новая проблема заключается в идентификации более дорогих скоропортящихся товаров, чтобы магазин мог выставить их на продажу раньше, чем менее дорогие товары. В этом случае наша модель потребует нового атрибута, такого как `Цена`, чтобы программа или решение могли определить, какой товар более ценен. Вот как будет выглядеть наша новая модель:

```csharp
public class Элемент
{
	public double Цена {get; set;} 
	public DateTimeOffset ДатаИстеченияСрока {get; set;} 
}
```

### 0.1.2.0 Типы моделей
Модели управляют всем процессом симуляции проблемы (и её решения). Модели делятся на три основные категории: носители данных, операционные и конфигурации. Давайте рассмотрим эти типы в следующих разделах:

#### 0.1.2.0.0 Модели носителей данных
Модели носителей данных имеют одну основную цель: перенос данных между системами. Они могут различаться в зависимости от типа данных, которые они переносят. Некоторые модели переносят другие модели для представления сложной системы, в то время как другие представляют ссылки на исходные точки данных.

Модели носителей данных в реляционном виде можно разделить на три разных категории. Эти категории делают приоритетное развитие, проектирование и инженерные области намного более ясными. Например, мы можем начать разработку вторичных/поддерживающих моделей только после того, как будут готовы наши первичные модели. Давайте обсудим эти категории более подробно:

#### 0.1.2.0.0.0 Первичные модели
Первичные модели являются основой каждой системы. Любая данная система может продолжить проектирование и инженерное развитие только с четким определением и материализацией этих первичных моделей. Например, если мы строим образовательную систему, такие модели, как `Студент`, `Преподаватель` и `Курс`, считаются первичными моделями.

Модели реляционного хранения данных не содержат внешние ключи или ссылки на какие-либо другие физические модели. Мы называем эти модели первичными, потому что они являются самодостаточными. Они не зависят физически от какой-либо другой модели для существования. Это означает, что данная первичная модель, такая как `Студент`, может существовать в образовательной системе независимо от того, существует ли запись о `Преподаватель` или нет. Это называется физической зависимостью.

Однако первичные модели могут концептуально или логически зависеть от других моделей. Например, модель `Студент` имеет логическую связь с моделью `Преподаватель`, просто потому что не может быть студента без учителя и наоборот. Модель `Студент` также имеет концептуальную связь со своими хостинговыми и соседними хостинговыми сервисами. Например, существует концептуальная связь между моделью `Студент` и моделью `Уведомление` относительно бизнес-процесса. Любой студент в любой школе концептуально зависит от уведомлений для посещения занятий и выполнения заданий или других событий.

#### 0.1.2.0.0.1 Вторичные модели
С другой стороны, *вторичные* модели имеют жесткую зависимость от первичных моделей. В реляционной модели базы данных вторичные модели обычно имеют внешние ключи, ссылающиеся на другую модель в общей схеме базы данных. Но даже в нереляционных системах хранения вторичные модели могут быть представлены как вложенные сущности внутри данной более крупной сущности или иметь свободную ссылку на другую сущность.

Рассмотрим некоторые примеры вторичных моделей. Модель `Комментарий` в социальной сети не может существовать без модели `Пост`. Вы не можете прокомментировать то, что не существует. В реляционной базе данных модель комментариев будет выглядеть следующим образом:

<br />
	<div align=center>
		<img width="45%" src="" />
	</div>
<br />

В приведенном выше примере вторичная модель `Комментарий` имеет внешний ключ `ИдентификаторПоста`, ссылающийся на первичный ключ `Идентификатор` в модели `Пост`. В нереляционной системе вторичные модели можно легко идентифицировать как вложенные объекты внутри данной сущности. Вот пример:

```json
{
	"идентификатор": "некоторый-id",
	"содержание": "некоторый пост",
	"комментарии": [
		{
			"идентификатор": "id-комментария",
			"содержание": "некоторый комментарий"
		}
	]
}
```

Вторичные модели могут иметь логические и концептуальные связи с другими моделями внутри их хоста, соседних или внешних систем. Однако вероятность наличия этих концептуальных связей у них значительно меньше, чем у первичных моделей.

#### 0.1.2.0.0.2 Реляционные модели
Реляционные модели являются связующими элементами между двумя первичными моделями. Их основная задача — реализовывать отношения многие-ко-многим между двумя сущностями. Например, у `Студента` может быть несколько учителей, а у `Учителя` может быть несколько студентов. В этом случае нам нужна реляционная модель для выполнения функции промежуточной модели.

Реляционные модели не должны содержать никаких деталей. Они только содержат ссылки на другие модели, которые являются их первичными ключами. Композитный ключ агрегирует два или более внешних ключа. Рассмотрим пример:

<br />
	<div align=center>
		<img width="45%" src="" />
	</div>
<br />

#### 0.1.2.0.0.3 Гибридные модели
Существует ситуация, когда модель соединяет несколько сущностей, но также содержит свои данные. Я настоятельно не рекомендую следовать этому пути, чтобы сохранить чистоту проектирования системы и контролировать сложность ваших моделей. Однако этот подход иногда является необходимым вариантом для реализации определённого потока бизнес-процессов. В этом случае мы можем предложить гибридную модель, которая может содержать определённые детали о связи между двумя независимыми сущностями.

Гибридная модель может описывать связь между двумя сущностями в сценарии многие-ко-многим с мягким удалением. Вот пример гибридной модели, которая может возникнуть на практике. Предположим, что участник группы больше не хочет быть частью этой группы. Мы рассматриваем их членство в группе как `Деактивированное` с указанием причины, не удаляя запись. Вот как это будет выглядеть:

<br />
	<div align=center>
		<img width="45%" src="" />
	</div>
<br />

Гибридные модели сочетают вторичные модели таким образом, как они ссылаются на первичные модели. Они реализуют реляционную природу, позволяя нескольким сущностям взаимосвязываться друг с другом без исключительности. В нереляционной модели данных целостность ссылок может стать менее строгой, учитывая линейную природу этой схемы.

#### 0.1.2.0.1 Операционные модели
Операционные модели в основном нацелены на аспект симуляции любой системы программного обеспечения. Подумайте обо всех примитивных, сложных и экспозицированных операциях, которые может потребовать простой сценарий для успешной симуляции. Предположим, мы пытаемся решить проблему, как упростить регистрацию студентов в некоторых школах. Процесс регистрации потребует некоторой симуляции для добавления информации о студентах в компьютеризированную систему.

Операционные модели будут обрабатывать весь процесс экспозиции, обработки и интеграции, предлагая сервисы, которые предоставляют API/интерфейсы для ввода, публикации, добавления и сохранения информации о студентах в некоторые образовательные системы.

Стандарт сосредоточен на операционных моделях, потому что они представляют ядро любой системы с точки зрения бизнес-процессов. Операционные модели также являются местом, где сосредоточены большинство ресурсов разработки и проектирования в любом проекте по разработке программного обеспечения. Операционные модели можно разбить на три основные категории: интеграция, обработка и экспозиция.

Давайте обсудим операционные модели здесь.

#### 0.1.2.0.1.0 Модели интеграции (Брокеры)
Основная ответственность операционных моделей интеграции — соединение любой существующей системы с внешними ресурсами, которые могут находиться локально в среде системы, например, чтение текущей даты или времени, либо удалённо, например, вызов внешнего API или сохранение данных в базе данных.

Мы называем эти интеграционные модели Брокеры. Они играют роль посредника между операционными моделями обработки и внешними системами. Вот пример:

```csharp
public partial class АпиБрокер
{
    public async ValueTask<Студент> ОтправитьСтудентаАсинхронно(Студент студент) =>
        await this.апиброкер.ОтправитьАсинхронно<Студент>(студент, адрес);
}
```

Модель интеграции выше предоставляет возможность вызывать внешнее API, скрывая детали конфигурации от моделей обработки операционных процессов.

Как и любой другой тип операционной модели, они не хранят данные, а вместо этого используют закрытые члены класса и константы для обмена внутренними данными между своими публичными и закрытыми методами. `АпиБрокер` здесь представляет собой модель, симулирующую интеграцию с внешней системой.

В следующих главах мы подробно обсудим брокеров, чтобы разъяснить правила и рекомендации по разработке брокеров с внешними ресурсами или системами.

#### 0.1.2.0.1.1 Модели обработки (Сервисы)
Модели обработки являются держателями всех бизнес-специфических симуляций, таких как регистрация студентов, запрос новой библиотечной карты или извлечение информации о студенте на основе конкретных критериев. Модели обработки могут быть либо примитивными/основными, высокоуровневыми/обрабатывающими, либо продвинутыми/координирующими.

Модели обработки, как правило, либо зависят от интеграционных моделей, либо являются независимыми, например, вычислительные службы, или зависят друг от друга.

Вот пример простого основного/примитивного сервиса:

```csharp
public partial class СервисСтудента : IСервисСтудента
{
    private readonly IХранилищеБрокер хранилищеБрокер;
    ...

    public async ValueTask<Студент> ДобавитьСтудентаАсинхронно(Студент студент) =>
        await this.хранилищеБрокер.ВставитьСтудентаАсинхронно(студент);
}
```

Сервис более высокого порядка будет выглядеть следующим образом:

```csharp
public partial class СервисОбработкиСтудентов : IСервисОбработкиСтудентов
{
    private readonly IСервисСтудента сервисСтудента;
    ...

    public async ValueTask<Студент> ВставитьИлиОбновитьСтудентаАсинхронно(Студент студент)
    {
        ...

        Студент возможныйСтудент = await this.сервисСтудента
            .ПолучитьСтудентаПоИдентификаторуАсинхронно(студент.Идентификатор);

        return возможныйСтудент switch
        {
            null => await this.сервисСтудента.ДобавитьСтудентаАсинхронно(студент),
            _ => await this.сервисСтудента.ИзменитьСтудентаАсинхронно(студент)
        };
    }
}
```

Более сложные услуги оркестрации будут объединять несколько обработок или фундаментальных услуг следующим образом:

```csharp
public partial class СервисОркестровкиСтудента : IСервисОркестровкиСтудента
{
    private readonly IСервисОбработкиСтудентов сервисОбработкиСтудентов;
    private readonly IСервисОбработкиСтуденческихБилетов сервисОбработкиСтуденческихБилетов;
    ...

    public async ValueTask<Студент> ЗарегистрироватьСтудентаАсинхронно(Студент студент)
    {
        ...
        Студент вставленныйИлиОбновлённыйСтудент = await this.сервисОбработкиСтудентов
            .ВставитьИлиОбновитьСтудентаАсинхронно(студент);

        ...

        await this.сервисОбработкиСтуденческихБилетов
            .ДобавитьСтуденческийБилетАсинхронно(студенческийБилет);
    }
}
```

В общем, операционные модели занимаются только симуляцией или обработкой конкретных моделей переносчиков данных; они не занимаются хранением данных или поддержанием статуса. Обычно операционные модели не хранят никаких данных, прошедших через них, кроме делегирования логирования для наблюдения и мониторинга.

#### 0.1.2.0.1.2 Модели экспозиции (Экспозиторы)
Модели экспозиции управляют пользовательским интерфейсом во всех сценариях взаимодействия людей и систем. Это могут быть простые RESTful API (RESTful интерфейсы прикладного программирования) и SDK (наборы средств разработки), а также пользовательские интерфейсы, такие как веб-приложения, мобильные или настольные приложения, включая системы/терминалы на командной строке.

Модели экспозиции аналогичны моделям интеграции; они позволяют внешнему миру взаимодействовать с вашей системой. Они находятся на другой стороне любой системы и отвечают за маршрутизацию каждого запроса, коммуникации или вызова к соответствующим операционным моделям. Модели экспозиции никогда не общаются напрямую с моделями интеграции и не имеют никакой конфигурации, кроме зависимостей, внедрённых через конструкторы.

Модели экспозиции могут использовать свой собственный язык в терминах операций; например, модель интеграции может использовать термин `ВставитьСтудента`, в то время как модель экспозиции для API-эндпоинта будет использовать термин `ОтправитьСтудента`, чтобы выразить ту же операцию в контексте экспозиции.

Вот пример моделей экспозиции:

```csharp
public class КонтроллерСтудентов
{
    private readonly IСервисОркестровкиСтудента сервисОркестровкиСтудента;

    [HttpPost]
    public async ValueTask<ActionResult<Студент>> ОтправитьСтудентаАсинхронно(Студент студент)
    {
        Студент зарегистрированныйСтудент = await this.сервисОркестровкиСтудента
            .ЗарегистрироватьСтудентаАсинхронно(студент);

        return Ok(зарегистрированныйСтудент);
    }
}
```

Приведённая выше модель открывает конечную точку API для RESTful общения, позволяя регистрировать студентов в образовательной системе. Мы будем подробно обсуждать типы моделей экспозиции в зависимости от контекста и систем, в которых они реализованы.

#### 0.1.2.0.2 Mодели конфигурации
Последний тип модели в любой системе — это конфигурационная модель. Она может представлять собой точку входа в систему, регистрировать зависимости для любой системы или действовать как посредник для маршрутизации URL-адресов в их соответствующие функции в модели экспозиции.

Конфигурационные модели обычно появляются в начале запуска системы, обрабатывая входящие и исходящие коммуникации или основные системные операции, такие как кэширование памяти, управление потоками и т.д.

В простой API-приложении вы можете увидеть модели, похожие на следующие:

```csharp
public class Startup
{
	public void ConfigureServices(IServiceCollection services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

Как видно из приведенного выше фрагмента кода, модель конфигурации `Startup` предоставляет возможности для обработки регистрации зависимостей, связывая контракты с их конкретными реализациями. Она может также заниматься добавлением безопасности или настройкой конвейера промежуточного ПО. Модели конфигурации зависят от технологии и могут отличаться от Play Framework в Scala до Spring или Flex в Python или Java. Мы опишем основные правила для моделей конфигурации в соответствии со Стандартом, но не будем углубляться в детали их реализации.

## 0.1.3 Симуляция

Аспект симуляции в программной инженерии — это наша способность имитировать взаимодействия между моделями. Например, в примере с продуктовыми магазинами симуляция будет заключаться в *продаже* товара. Продажа товара требует множества изменений в товаре, таких как уменьшение количества доступных товаров и переупорядочивание оставшихся товаров на основе их ценности.

Мы можем описать процесс симуляции как иллюстрацию отношений между моделями, которые программируются как `функции`, `методы` или `процедуры`; эти термины обозначают одно и то же. Если у нас есть программный сервис, ответственный за продажи товаров, процесс симуляции может выглядеть следующим образом:

```csharp
public class СервисПродаж
{
    public void Продать(Товар товар) => Товары.Удалить(товар);
}
```

В приведённом выше примере у нас есть модель, называемая `СервисПродаж`, которая предоставляет функциональность для симуляции процесса продажи в реальном мире на модели товара. И именно так вы описываете всё в объектно-ориентированном программировании. Всё является объектом (от модели), и эти объекты взаимодействуют друг с другом (симуляция).

Взаимодействие объектов в целом можно наблюдать в трёх разных типах. Модель выполняет действие над другой моделью. Например, `СервисПродаж` выполняет действие `Продать` над моделью `Товар`. Это взаимодействие модели с другой моделью. В том же примере симуляция может быть чем-то, что происходит с моделью от другой модели, такой как `Товар` в приведённом выше примере. Последний тип симуляции — это взаимодействие модели с самой собой, например, модели, которые уничтожаются сами, как только их цель достигнута, так как они больше не нужны и самоуничтожаются.

Процесс симуляции — это третий и последний аспект программной инженерии. Мы будем глубже исследовать его, когда будем обсуждать брокеры, сервисы и экспозеры, чтобы иллюстрировать, как происходит моделирование и симуляция в промышленном программном обеспечении.

## 0.1.4 Итог

Если рассматривать *цель* как домен или фреймворк, в рамках которого модели взаимодействуют, то следующее изображение должно упростить и более ясно передать картину:

<br />
	<div align=center>
		<img width="55%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard-Russian/refs/heads/main/0.%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5/%D0%A0%D0%B5%D1%81%D1%83%D1%80%D1%81%D1%8B/%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%2C%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F/Purposing%20Modeling%20%26%20Simulation-2.drawio.png" />
	</div>
<br />

Важно понимать, что компьютерное программное обеспечение может служить нескольким целям. Компьютерное программное обеспечение может взаимодействовать с другим программным обеспечением, которое имеет общие цели. Цель программного обеспечения становится моделью, а интеграции становятся симуляциями в этом аспекте. Вот пример с высоты 10 000 футов:

<br />
	<div align=center>
		<img width="75%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard-Russian/refs/heads/main/0.%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5/%D0%A0%D0%B5%D1%81%D1%83%D1%80%D1%81%D1%8B/%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%2C%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F/Purposing%20Modeling%20%26%20Simulation-3.drawio.png" />
	</div>
<br />

Сложность любой большой системы можно разбить на более мелкие проблемы, если для каждой подсистемы соблюдается аспект единой цели или единой ответственности. Современные архитектуры программного обеспечения называют это гранулярностью и модульностью, что мы кратко обсудим в аспекте архитектуры Стандарта.

[*] [Назначение, Моделирование и Симуляция (Часть 1 на английском)](https://www.youtube.com/watch?v=Doul1gZKCuU)
