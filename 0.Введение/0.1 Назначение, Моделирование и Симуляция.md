# 0.1 Назначение, Моделирование и Симуляция

## 0.1.0 Введение

Стандарт определяет процесс разработки программного обеспечения в трех основных категориях: Назначение(Purposing), Моделирование(Modeling) и Симуляция(Simulation). Каждый аспект важен для того, чтобы направить инженерные усилия к успешному решению и выполнению задачи.

Последовательность следования этих аспектов также не случайна. Назначение должно существовать для того, чтобы формировать процесс моделирования, а симуляцию нельзя проводить без моделей. Однако, хотя этот порядок важен на начальном этапе инженерного процесса, важно понимать, что процесс выборочно итеративен. Изменение назначения может повлиять на симуляцию, но не обязательно на моделирование, а изменение моделей не всегда требует изменения назначения или симуляции.

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148862410-f4ce62ad-deaa-4376-af1c-c43b9aa53473.png" />
	</div>
<br />

## 0.1.1 Назначение(Purposing)

Процесс назначения — это наша способность выяснить, зачем нам нужно решение. Например, если у нас есть проблема с подсчетом количества товаров на полке в продуктовом магазине, мы считаем, что процесс ручного подсчета неэффективен, и требуется система, чтобы обеспечить правильный учет товаров.

Размышление во многом опирается на нашу способность наблюдать за проблемами, а затем формулировать проблему для разработки решения, которое устранит данную проблему. Назначение, таким образом, — это поиск причины для действий.

Итак, у нас есть наблюдение, формулировка причины (проблемы) и намерение найти решение. Все эти аспекты составляют часть Назначения в разработке программного обеспечения.

### 0.1.1.0 Наблюдение

Мы живем в мире, полном объектов наблюдения. Наше вдохновение вызывается нашей амбицией достигать большего. Наши мечты выявляют преграды на нашем пути, которые нужно решить, чтобы продолжить наше путешествие и воплотить мечты в жизнь. С момента, когда молодой студент использует калькулятор для решения сложного уравнения, до момента, когда этот же студент становится астронавтом, рассчитывающим траекторию спутников, вращающихся вокруг нашей планеты.

Наблюдение — это наша способность обнаружить проблему, которая блокирует достижение цели. Проблемы могут быть простыми, как правильный подсчет товаров на полке магазина, или сложными, как понимание того, почему мы не можем сделать снимки планет, находящихся на миллионы световых лет от нас. Инженеры называют это наблюдаемыми проблемами.

Чем больше цель, тем сложнее будет проблема. Но начинать с меньших целей — это способ тренировать наш ум для решения более крупных — шаг за шагом, по одной проблеме за раз.

### 0.1.1.1 Формулировка

Описание наблюдаемого — это искусство само по себе, потому что хорошо сформулированная проблема — это уже половина решения. Чем яснее формулировка проблемы, тем больше вероятность, что другие поймут её, что поможет в решении этой же проблемы.

Формулировка не всегда выражается словами. Это также могут быть фигуры и формы. Недаром некоторые из самых развитых древних культур использовали фигуры и формы для описания своего времени и истории. Фигуры — это универсальный язык, который быстрее воспринимается и интерпретируется кем-либо, чем изучение разговорного языка. Фигура или форма может быть самым оптимальным способом иллюстрации идеи, так как изображения ценнее тысячи слов.

Формулировка требует страсти к решению проблемы, будь она написана, произнесена или иллюстрирована. Страстный ум передает скрытое сообщение о критичности проблемы, которую нужно решить. Формулирование проблемы — важная часть презентации решения. Наша способность донести идею до других инженеров и тех, кто инвестирует и использует это решение, является одним из самых важных аспектов разработки программного обеспечения.

### 0.1.1.2 Решение

Часть назначения — это способ его выполнения. В индустрии разработки достижение целей не может происходить "любыми средствами". Программное обеспечение терпит неудачи по всему миру, потому что аспект решения был упущен как тривиальная часть назначения. Возможно, вы слышали о инженерах, которые, столкнувшись с крайним сроком, решают пойти на компромиссы для достижения цели. В нашем Стандарте это является нарушением. Решение *должно* не просто достигать цели, но и само быть частью назначения, чтобы способствовать решению таких вопросов, как оптимизация, читаемость, конфигурируемость и долговечность. Решение является частью назначения в искусстве разработки программного обеспечения.

## 0.1.2 Моделирование(Modeling)

Моделирование — второй по важности аспект разработки программного обеспечения. Мы можем извлекать модели из участников любой проблемы, будь то живые существа, объекты или другие элементы. Мы извлекаем только те атрибуты, которые важны для решения проблемы, и отбрасываем всё остальное. Например, при подсчете товаров на полке в продуктовом магазине нам понадобится модель для этих товаров.

Более простой пример — обнаружение скоропортящихся товаров в магазине. Единственный атрибут, который нас здесь интересует, — это срок годности товара. Все остальное, включая этикетку, цвет, вес или любые другие детали, не имеет отношения к процессу моделирования и решению.

Моделирование, таким образом, может существовать только при наличии цели. Цель определяет рамки, в пределах которых должно происходить моделирование. Моделирование без цели оставляет открытой дверь для привлечения бесконечного количества атрибутов, которые может иметь каждый элемент наблюдаемой вселенной.

Отношение между назначением и атрибутами моделирования пропорционально. Чем сложнее цель, тем более вероятно, что процесс моделирования потребует больше атрибутов из реального мира для моделирования в решении.

Мы выражаем наши модели на языках программирования в виде `class`. Проблема скоропортящихся товаров, упомянутая выше, может быть представлена следующим образом:

```csharp
public class Item
{
	public DateTimeOffset ExpirationDate {get; set;}
}
```

Название `class` представляет собой общий *тип* элемента. Поскольку все элементы имеют одинаковый атрибут `ExpirationDate`, имя должно оставаться максимально общим.

Теперь представьте, что наша цель стала более сложной. Допустим, новая проблема заключается в идентификации более дорогих скоропортящихся товаров, чтобы магазин мог выставить их на продажу раньше, чем менее дорогие товары. В этом случае наша модель потребует нового атрибута, такого как `Price`, чтобы программа или решение могли определить, какой товар более ценен. Вот как будет выглядеть наша новая модель:

```csharp
public class Item
{
	public double Price {get; set;}
	public DateTimeOffset ExpirationDate {get; set;}
}
```

### 0.1.2.0 Типы моделей
Модели управляют всем процессом симуляции проблемы (и её решения). Модели делятся на три основные категории: Data Carriers, Operational и Configurations. Давайте рассмотрим эти типы в следующих разделах:

#### 0.1.2.0.0 Модели Data Carrier
Модели data carrier имеют одну основную цель: перенос данных между системами. Они могут различаться в зависимости от типа данных, которые они переносят. Некоторые модели переносят другие модели для представления сложной системы, в то время как другие представляют ссылки на исходные точки данных.

Модели data carrier в реляционном виде можно разделить на три разных категории. Эти категории делают приоритетное развитие, проектирование и инженерные области намного более ясными. Например, мы можем начать разработку вторичных/поддерживающих моделей только после того, как будут готовы наши первичные модели. Давайте обсудим эти категории более подробно:

#### 0.1.2.0.0.0 Первичные модели
Первичные модели являются основой каждой системы. Любая данная система может продолжить проектирование и инженерное развитие только с четким определением и материализацией этих первичных моделей. Например, если мы строим образовательную систему, такие модели, как `Student`, `Teacher` и `Course`, считаются первичными моделями.

Модели реляционного хранения данных не содержат внешние ключи или ссылки на какие-либо другие физические модели. Мы называем эти модели первичными, потому что они являются самодостаточными. Они не зависят физически от какой-либо другой модели для существования. Это означает, что данная первичная модель, такая как `Student`, может существовать в образовательной системе независимо от того, существует ли запись о `Teacher` или нет. Это называется физической зависимостью.

Однако первичные модели могут концептуально или логически зависеть от других моделей. Например, модель `Student` имеет логическую связь с моделью `Teacher`, просто потому что не может быть студента без учителя и наоборот. Модель `Student` также имеет концептуальную связь со своими хостинговыми и соседними хостинговыми сервисами. Например, существует концептуальная связь между моделью `Student` и моделью `Notification` относительно бизнес-процесса. Любой студент в любой школе концептуально зависит от уведомлений для посещения занятий и выполнения заданий или других событий.

#### 0.1.2.0.0.1 Вторичные модели
С другой стороны, *вторичные* модели имеют жесткую зависимость от первичных моделей. В реляционной модели базы данных вторичные модели обычно имеют внешние ключи, ссылающиеся на другую модель в общей схеме базы данных. Но даже в нереляционных системах хранения вторичные модели могут быть представлены как вложенные сущности внутри данной более крупной сущности или иметь свободную ссылку на другую сущность.

Рассмотрим некоторые примеры вторичных моделей. Модель `Comment` в социальной сети не может существовать без модели `Post`. Вы не можете прокомментировать то, что не существует. В реляционной базе данных модель комментариев будет выглядеть следующим образом:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897099-5dd8aa3d-f6c2-4504-ba42-5e911c21a09a.png" />
</div>

<br />

В приведенном выше примере вторичная модель `Comment` имеет внешний ключ `PostId`, ссылающийся на первичный ключ `Id` в модели `Post`. В нереляционной системе вторичные модели можно легко идентифицировать как вложенные объекты внутри данной сущности. Вот пример:

```json
{
	"id": "some-id",
	"content": "some post",
	"comments": [
		{
			"id": "comment-id",
			"content": "some comment"
		}
	]
}
```

Вторичные модели могут иметь логические и концептуальные связи с другими моделями внутри их хоста, соседних или внешних систем. Однако вероятность наличия этих концептуальных связей у них значительно меньше, чем у первичных моделей.

#### 0.1.2.0.0.2 Реляционные модели
Реляционные модели являются соединителями между двумя первичными моделями. Их основная ответственность — материализовать многие-ко-многим отношения между двумя сущностями. Например, `Student` может иметь несколько учителей, а `Teacher` может иметь несколько студентов. В этом случае нам нужна реляционная модель для выполнения функции промежуточной модели.

Реляционные модели не должны содержать никаких деталей. Они только содержат ссылки на другие модели, которые являются их первичными ключами. Композитный ключ агрегирует два или более внешних ключа. Рассмотрим пример:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897988-f865d0ef-9e22-421f-afe8-8d987bb67464.png" />
</div>

<br />

#### 0.1.2.0.0.3 Гибридные модели
Существует ситуация, когда модель соединяет несколько сущностей, но также содержит свои данные. Я настоятельно не рекомендую следовать этому пути, чтобы сохранить чистоту проектирования системы и контролировать сложность ваших моделей. Однако этот подход иногда является необходимым вариантом для реализации определённого потока бизнес-процессов. В этом случае мы можем предложить гибридную модель, которая может содержать определённые детали о связи между двумя независимыми сущностями.

Гибридная модель может описывать отделение между двумя сущностями в сценарии многие-ко-многим в сценарии мягкого удаления. Вот пример гибридной модели, которая может возникнуть на практике. Предположим, что участник группы больше не хочет быть частью этой группы. Мы рассматриваем их членство в группе как `Deactivated` с указанием причины, не удаляя запись. Вот как это будет выглядеть:

<br />
<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155970437-3599c84c-b27a-471f-979a-17b624dd6b63.png" />
</div>
<br />

Гибридные модели сочетают вторичные модели таким образом, как они ссылаются на первичные модели. Они реализуют реляционную природу, позволяя нескольким сущностям взаимосвязываться друг с другом без исключительности. В нереляционной модели данных целостность ссылок может стать менее строгой, учитывая линейную природу этой схемы.

#### 0.1.2.0.1 Операционные модели
Операционные модели в основном нацелены на аспект симуляции любой системы программного обеспечения. Подумайте обо всех примитивных, сложных и экспозицированных операциях, которые может потребовать простой сценарий для успешной симуляции. Предположим, мы пытаемся решить проблему, как упростить регистрацию студентов в некоторых школах. Процесс регистрации потребует некоторой симуляции для добавления информации о студентах в компьютеризированную систему.

Операционные модели будут обрабатывать весь процесс экспозиции, обработки и интеграции, предлагая сервисы, которые предоставляют API/интерфейсы для ввода, публикации, добавления и сохранения информации о студентах в некоторые образовательные системы.

Стандарт сосредоточен на операционных моделях, потому что они представляют ядро любой системы с точки зрения бизнес-процессов. Операционные модели также являются местом, где сосредоточены большинство ресурсов разработки и проектирования в любом усилии по разработке программного обеспечения. Операционные модели можно разбить на три основные категории: Integration, Processing и Exposure.

Давайте обсудим операционные модели здесь.

#### 0.1.2.0.1.0 Модели интеграции (Брокеры)
Основная ответственность операционных моделей интеграции — соединение любой существующей системы с внешними ресурсами, которые могут быть локализованы в среде системы, например, чтение текущей даты или времени, или удалёнными, например, вызов внешнего API или сохранение данных в базе данных.

Мы называем эти интеграционные модели Брокеры. Они играют роль посредника между операционными моделями обработки и внешними системами. Вот пример:

```csharp
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

Модель интеграции выше предоставляет возможность вызывать внешнее API, скрывая детали конфигурации от моделей обработки операционных процессов.

Как и любой другой тип операционной модели, они не хранят данные, а вместо этого используют закрытые члены класса и константы для обмена внутренними данными между своими публичными и закрытыми методами. `ApiBroker` здесь представляет собой модель, симулирующую интеграцию с внешней системой.

В следующих главах мы подробно обсудим Brokers, чтобы разъяснить правила и рекомендации по разработке брокеров с внешними ресурсами или системами.

#### 0.1.2.0.1.1 Модели обработки (Сервисы)
Модели обработки являются держателями всех бизнес-специфических симуляций, таких как регистрация студентов, запрос новой библиотечной карты или извлечение информации о студенте на основе конкретных критериев. Модели обработки могут быть либо примитивными/основными, высокоуровневыми/обрабатывающими, либо продвинутыми/координирующими.

Модели обработки, как правило, либо зависят от интеграционных моделей, либо являются независимыми, например, вычислительные службы, или зависят друг от друга.

Вот пример простого основного/примитивного сервиса:

```csharp
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```

Сервис более высокого порядка будет выглядеть следующим образом:

```csharp
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

Более сложные услуги оркестрации будут объединять несколько обработок или фундаментальных услуг следующим образом:

```csharp
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryCardProcessingService
			.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

В общем, операционные модели занимаются только симуляцией или обработкой конкретных моделей переносчиков данных; они не занимаются хранением данных или поддержанием статуса. Обычно операционные модели не хранят никаких данных, прошедших через них, кроме делегирования логирования для наблюдения и мониторинга.

#### 0.1.2.0.1.2 Модели экспозиции (Экспозиторы)
Модели экспозиции управляют пользовательским интерфейсом во всех сценариях взаимодействия людей и систем. Это могут быть простые RESTful API и SDK, а также пользовательские интерфейсы, такие как веб-приложения, мобильные или настольные приложения, включая системы/терминалы на командной строке.

Модели экспозиции аналогичны моделям интеграции; они позволяют внешнему миру взаимодействовать с вашей системой. Они находятся на другой стороне любой системы и отвечают за маршрутизацию каждого запроса, коммуникации или вызова к соответствующим операционным моделям. Модели экспозиции никогда не общаются напрямую с моделями интеграции и не имеют никакой конфигурации, кроме зависимостей, внедрённых через конструкторы.

Модели экспозиции могут использовать свой язык в терминах операций; например, модель интеграции может использовать язык вроде `InsertStudent`, в то время как модель экспозиции для API-эндпоинта будет использовать язык вроде `PostStudent`, чтобы выразить ту же операцию в контексте экспозиции.

Вот пример моделей экспозиции:

```csharp
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpPost]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

Приведённая выше модель открывает конечную точку API для RESTful общения, позволяя регистрировать студентов в образовательной системе. Мы будем подробно обсуждать типы моделей экспозиции в зависимости от контекста и систем, в которых они реализованы.

#### 0.1.2.0.2 Mодели конфигурации
Последний тип модели в любой системе — это конфигурационная модель. Она может представлять собой точку входа в систему, регистрировать зависимости для любой системы или действовать как посредник для маршрутизации URL-адресов в их соответствующие функции в модели экспозиции.

Конфигурационные модели обычно появляются в начале запуска системы, обрабатывая входящие и исходящие коммуникации или основные системные операции, такие как кэширование памяти, управление потоками и т.д.

В простой API-приложении вы можете увидеть модели, похожие на следующие:

```csharp
public class Startup
{
	public void ConfigureServices(IServiceCollection services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

Как видно из приведенного выше фрагмента кода, модель конфигурации `Startup` предоставляет возможности для обработки регистрации зависимостей, связывая контракты с их конкретными реализациями. Она может также заниматься добавлением безопасности или настройкой конвейера промежуточного ПО. Модели конфигурации зависят от технологии и могут отличаться от Play Framework в Scala до Spring или Flex в Python или Java. Мы опишем основные правила для моделей конфигурации в соответствии со Стандартом, но не будем углубляться в детали их реализации.

## 0.1.3 Симуляция(Simulation)

Аспект симуляции в программной инженерии — это наша способность имитировать взаимодействия между моделями. Например, в примере с продуктовыми магазинами симуляция будет заключаться в *продаже* товара. Продажа товара требует множества изменений в товаре, таких как уменьшение количества доступных товаров и переупорядочивание оставшихся товаров на основе их ценности.

Мы можем описать процесс симуляции как иллюстрацию отношений между моделями, которые программируются как `функции`, `методы` или `процедуры`; эти термины обозначают одно и то же. Если у нас есть программный сервис, ответственный за продажи товаров, процесс симуляции может выглядеть следующим образом:

```csharp
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

В приведенном выше примере у нас есть модель, называемая `SaleService`, которая предоставляет функциональность для симуляции процесса продажи в реальном мире на модели товара. И именно так вы описываете все в объектно-ориентированном программировании. Все является объектом (от модели), и эти объекты взаимодействуют друг с другом (симуляция).

Взаимодействие объектов в целом можно наблюдать в трех разных типах. Модель выполняет действие над другой моделью. Например, `SaleService` выполняет действие `Sell` над моделью `Item`. Это взаимодействие модели с другой моделью. В том же примере симуляция может быть чем-то, что происходит с моделью от другой модели, такой как `Item` в приведенном выше примере. Последний тип симуляции — это взаимодействие модели с самой собой, например, модели, которые уничтожаются сами, как только их цель достигнута, так как они больше не нужны и самоуничтожаются.

Процесс симуляции — это третий и последний аспект программной инженерии. Мы будем глубже исследовать его, когда будем обсуждать брокеры, сервисы и экспозеры, чтобы иллюстрировать, как происходит моделирование и симуляция в промышленном программном обеспечении.

## 0.1.4 Итог

Если рассматривать *цель* как домен или фреймворк, в рамках которого модели взаимодействуют, то следующее изображение должно упростить и более ясно передать картину:

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148863196-a30ced43-7133-4107-a23f-d0beb3efa6db.png" />
	</div>
<br />

Важно понимать, что компьютерное программное обеспечение может служить нескольким целям. Компьютерное программное обеспечение может взаимодействовать с другим программным обеспечением, которое имеет общие цели. Цель программного обеспечения становится моделью, а интеграции становятся симуляциями в этом аспекте. Вот пример с высоты 10 000 футов:

<br />
	<div align=center>
		<img width="75%" src="https://user-images.githubusercontent.com/1453985/148863514-2ed0fe04-1096-42c3-b54a-3b8dbd506e7a.png" />
	</div>
<br />

Сложность любой большой системы можно разбить на более мелкие проблемы, если для каждой подсистемы соблюдается аспект единой цели или единой ответственности. Современные архитектуры программного обеспечения называют это гранулярностью и модульностью, что мы кратко обсудим в аспекте архитектуры Стандарта.

[*] [Назначение, Моделирование и Симуляция (Часть 1 на английском)](https://www.youtube.com/watch?v=Doul1gZKCuU)
