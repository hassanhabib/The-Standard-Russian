# 0.2 Принципы
В этой главе мы рассмотрим принципы Стандарта. Эти принципы применяются ко всем компонентам системы, соответствующей Стандарту, независимо от того, являются ли эти компоненты брокерами, сервисами или экспозерами.

## 0.2.0 Люди прежде всего
Основная идея этого принципа - создавать и проектировать системы, соответствующие Стандарту, с учетом людей. Речь идет не только о людях, которые будут использовать систему, но и о тех, кто будет заниматься её поддержкой и развитием.

Система должна отдавать предпочтение простоте, а не сложности, чтобы соответствовать принципу "Люди прежде всего". Простота обеспечивает возможность переписывания. Она также приводит к созданию монолитных систем, разработанных с модульным подходом, что позволяет достичь подлинной фрактальности в общей структуре системы.

Стандарт также требует соотносить сложные инженерные концепции с уровнем понимания рядовых инженеров. Новые специалисты в отрасли - это завтрашние лидеры. Если они не примут систему, в конечном итоге они откажутся от нее и будут постоянно переписывать.

### 0.2.0.0 Простота
Код, написанный в соответствии со Стандартом, должен быть простым. Для обеспечения этой простоты предусмотрены следующие меры:

#### 0.2.0.0.0 Чрезмерное наследование
Любое программное обеспечение, разработанное в соответствии со Стандартом, не должно иметь более одного уровня наследования. Наследование более чем одного уровня считается чрезмерным и запрещено, за исключением случаев версионирования для вертикального масштабирования процессов. Многолетний опыт доказал, что чрезмерное наследование ухудшает читаемость и сопровождаемость кода.

#### 0.2.0.0.1 Зацепление

##### 0.2.0.0.1.0 Горизонтальное зацепление
Создание "общих" компонентов в каждой системе, которые якобы упрощают процесс разработки, является запрещённой практикой в системах, соответствующих Стандарту. Эта практика проявляется в компонентах с названиями типа `Utils`, `Commons` или `Helpers`. Подобные термины и связанные с ними ложные обещания упрощения не допускаются. Система, построенная по Стандарту, должна состоять только из Брокеров, Сервисов и Экспозеров - ни больше, ни меньше.

Ещё одним примером горизонтального зацепления является использование общих моделей для нескольких независимых процессов - общих исключений, правил валидации или любых других форм зацепления между разными процессами.

<br />
	<div align=center>
		<img src="https://user-images.githubusercontent.com/1453985/169941573-fe71c80a-ba03-449c-b690-913516176b01.png" />
	</div>
<br />

##### 0.2.0.0.1.1 Вертикальное зацепление
Этот принцип также применяется к сценариям использования базовых компонентов. Если эти базовые компоненты не являются нативными или внешними, они не допускаются в системе, соответствующей Стандарту. Локальные базовые компоненты создают вертикальный уровень зацепления, что вредит сопровождаемости и читаемости кода. Вертикальное зацепление так же вредно, как компоненты типа `Commons`, создавая единые точки отказа во всей системе.

Зацепление (вертикальное или горизонтальное) также мешает инженерам (особенно новичкам) полностью понимать глубину системы и владеть её функциональностью. Оно лишает инженеров возможности создавать сквозные процессы, когда половина функциональности компонентизирована ради ускорения разработки и мнимой простоты.

<br />
	<div align=center>
		<img src="https://user-images.githubusercontent.com/1453985/169942070-9336f6fd-b1bb-48e0-ac83-d7f5e7a13d38.png" />
	</div>
<br />

#### 0.2.0.0.2 Автономные компоненты
Каждый компонент в системе должен быть самодостаточным. Каждый компонент реализует свои проверки, инструменты и утилиты в одной из своих размерностей без жёстких зависимостей от других внешних компонентов, за исключением dependency injection. Этот принцип предпочитает дублирование мнимому упрощению через зацепление кода.

Автономные компоненты дают возможность каждому инженеру в команде полностью владеть всеми зависимостями и инструментами, необходимыми компоненту для выполнения его задач. Это может привести к некоторому дублированию кода, но открывает равные возможности для всех разработчиков учиться создавать и развивать компоненты.

##### 0.2.0.0.2.0 Никакой магии
Автономные компоненты выставляют все свои процедуры на виду у инженера. Никаких скрытых процедур, общих библиотек или магических расширений, требующих поиска ссылок при неизбежном разделении монолита.

Мы будем относиться к объектам как к природным явлениям: многомерным компонентам, самодостаточным как атомы в природе. Эти компоненты выполняют свои проверки, обработку исключений, трассировку, безопасность, локализацию и всё остальное.

<br />
	<div align=center>
		<img src="https://user-images.githubusercontent.com/1453985/169712032-3184e22a-d91f-4baa-a0f2-657de294220b.png" />
	</div>
<br />

Компоненты, созданные по Стандарту, строго следуют принципу "Что видишь, то и получаешь" (WYSIWYG, What You See Is What You Get) — всё, что касается компонента, должно быть в нём самом.

## 0.2.1 Переписываемость
Каждая система должна разрабатываться с учётом принципа переписываемости. Этот принцип гласит, что наши предположения в разрабатываемых системах могут быть пересмотрены. Каждая система должна быть легко переписываемой, чтобы соответствовать постоянно растущим и меняющимся бизнес-требованиям.

Переписываемый код легко понять, изменить и полностью переписать. Он модульный и автономный, что позволяет инженерам развивать его с минимальными усилиями и рисками.

Переписываемый код не обманывает читателя. Он должен быть plug-and-play — форкнуть, клонировать, собрать и запустить все тесты без проблем. Нет скрытых зависимостей, инжектируемых процедур во время выполнения или неизвестных предварительных условий.

## 0.2.2 Моно-Микро
Создавайте монолитные системы с модульным подходом, где каждый процесс полностью независим от других. Например, мы можем создать монолитную систему с микросервисным подходом, что означает, что любой процесс можно извлечь из системы и превратить в микросервис или лямбду с минимальными усилиями.

Этот принцип тесно связан с концепцией автономных компонентов на более высоком уровне, где процессы также автономны от соседних процессов и их системы-хоста.

## 0.2.3 Уровень 0
Код должен быть понятен начинающему инженеру. Поскольку большинство инженеров в отрасли всегда будут новичками, наш код продолжает жить благодаря своей простоте для понимания большинством инженеров.

Инженеры уровня 0 — наш критерий успеха. Их способность понять наш код гарантирует, что этот код будет жить и развиваться со следующим поколением инженеров.

Этот принцип также требует, чтобы каждый инженер тщательно проверял свой код и работал в паре с младшими коллегами, чтобы убедиться в соблюдении этого принципа.

## 0.2.4 Открытый код
Принцип открытого кода гласит, что всё, написанное по Стандарту, должно быть общедоступным. Это касается внутренних архитектурных практик, пробных библиотек и любых других форм разработки модулей, которые не позволяют каждому инженеру учиться и развивать систему. Разработка внутренних инструментов без доступа неизбежно вредит инженерному опыту тех, кто пытается их улучшать.

Принцип признаёт, что в исключительных случаях (угроза безопасности или контрактные обязательства) код может быть закрыт. Однако Стандарт запрещает делать исходный код проприетарным только для личной или организационной выгоды.

## 0.2.5 Режим "в самолёте"
Стандарт поддерживает идею режима "в самолёте", когда инженеры могут настроить всю инфраструктуру на локальной машине без сетевого подключения. Этот принцип противоречит концепциям типа Cloud-Native, где система не может работать без облачной инфраструктуры.

Стандарт также поощряет создание инструментов для моста между облачными и локальными компонентами (очереди, event hubs и др.), чтобы сделать систему легко тестируемой и изменяемой.

## 0.2.6 Нет тостерам
Стандарт должен передаваться от человека к человеку, а не через автоматические анализаторы кода. Не должно быть стилевых анализаторов, принуждающих следовать Стандарту. Он должен поддерживаться страстью и убеждённостью. Стандарт воспитывает культуру открытых обсуждений и понимания.

## 0.2.7 Передача знаний
Стандарт должен преподаваться бесплатно, как и был получен бесплатно. Он должен передаваться следующему инженеру безвозмездно, независимо от его финансового, социального или образовательного статуса. Стандарт — это чистое знание, данное бескорыстными для бескорыстных. Запрещается извлекать из него прибыль или использовать для унижения других. Преподавание Стандарта за деньги нарушает его и лишает нарушителя дальнейшего руководства от Автора.

## 0.2.8 Всё или ничего
Стандарт должен быть либо полностью принят, либо полностью отвергнут. Системы, включающие только некоторые аспекты Стандарта, не считаются стандартизированными. Системы, следующие предыдущим версиям Стандарта, обязаны обновиться, чтобы вернуть статус стандартизированных.

## 0.2.9 Читаемость важнее оптимизации
Читаемость важнее оптимизации. Если оптимизированный код нечитаем, то он не является по-настоящему оптимальным и стандартизированным. В случае сомнений Стандарт ставит читаемость выше оптимизации.

## 0.2.10 Последний день
Каждый день может быть последним для проекта. Поэтому каждая задача (дизайн, разработка, документация, тесты) должна быть доведена до логической точки остановки к концу рабочего дня. Инженеры, следующие Стандарту, должны оставлять работу в состоянии, пригодном для продолжения другим инженером на следующий день. Это обеспечивает непрерывность проекта и учитывает непредвиденные обстоятельства.